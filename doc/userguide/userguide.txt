HadesFIX Engine Architecture
HadesFIX engine architecture is based on the concept of FIX session. There can be only 2 types of session:
- client session - corresponds to the FIX session initiator. The client session attempts to connect to a server (FIX acceptor) using the TCP transport and logs in and establish a session with the server. 
- server session - corresponds to the FIX session acceptor. The server session wait for a client session to connect using the TCP transport, authenticates the client and starts a FIX session.
Both the client and the server are configured using a XML file. The schema of the XML configuration file can be found in the distribution "config" directory - HadesEngineConfig.xsd file. The instance configuration file is mandatory in order to start a HadesFIX engine.
A HadesFIX instance can host multiple client or server sessions that are connecting to the same or different counterparties.
Each FIX session, weather client or server, contains two Streams: a Consumer Stream and a Producer Stream.
The Consumer Stream is reading messages received from the counterparty using the connected FIX session and deliver these messages to the configured Consumer Flows inside that Stream. There can be multiple Consumer Flows configured for a Consumer stream.
The messages received by the Flow from their Stream are relayed to the chain of custom message Handlers. The last Handler in the configured chain is the pivot Handler and is responsible with the delivery of the message to the application layer. 
Any Handler in the chain can discard the received message if required. If the message is discarded by a Handler in the chain, the subsequent Handler will not receive the message.
The Consumer Flows can have Filters configured. A default message type filter can be configured using the "msgFilter" attributeon the Consumer Flow in which case only the message types specified in the comma sepparated list will be relayed to the Handlers in the flow. If more complex filtering is required then a custom Filter can be configured. The class implementing the Filter functionality must implement com.marvisan.hades.fix.filter.Filter interface. The COnsumer Flow "msgFilterClass" attribute configures a custome filter for the flow.
If N Consumer Flows are configured then at least N - 1 Filters must be specified otherwise all the messages will be consumed by the first flow configured. If a message is filtered then it will be passed to the next flow configured or discarded if no Consumer Flow exists. 
The Producer Stream relays messages received from the application layer to the counterparty using the connected FIX session. There can only be one Producer Flow configured for a Producer Stream. The Producer Flow in its turn will have configured a chain of custom message Handlers which will process messages received from the application layer. The last Handler configured in the chain is the pivot Handler and it is responsible with reading the messages from the application layer and forwarding these messages to the next Handler in chain for further processing.
Custom Handlers
There are 3 types of custom Handlers that can be developed:
- Consumer Handler that needs to extend com.marvisan.hades.fix.handler.AbstractConsumerHandler class. These handlers can only be configured inside a Consumer Flow and must override the "consume" method. A Consumer Handler implementation will have an instance created inside the Consumer Stream thread and will be able to create its own threads. The Handler implementation is responsible for managing its own created threads. In order for the processed message to be forwarded to the next message in chain the "super.consume()" method must be called before exiting the "consume" method, otherwise the message will be discarded.
- Producer Handler that needs to extend com.marvisan.hades.fix.handler.AbstractProducerHandler class. These handlers can only be configured inside a Producer Flow and must override the "produce" method. A Producer Handler implementation will have an instance created inside the Producer Stream thread and will be able to create its own threads. The Handler implementation is responsible for managing the created threads. In order for the processed message to be forwarded to the next message in chain the "super.produce()" method must be called before exiting the "produce" method, otherwise the message will be discarded.
- Producer/Consumer Handler that needs to extend com.marvisan.hades.fix.handler.AbstractProducerConsumerHandler class. These handlers can be configured in both Producer and Consumer Flows. This type of handlers will have a shared instance created in the Session Coordinator thread that will be called by the Consumer and Producer flows. Synchronisation must be taken care of inside the handler as different threads will call "consume" and "produce" methods.

